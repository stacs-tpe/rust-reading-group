<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Introduction to Rust</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="src/media/style.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "ayu" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                    </div>

                    <h1 class="menu-title">Introduction to Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>


                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <div class="title">
<h1 id="week-3-"><a class="header" href="#week-3-">Week 3 :)</a></h1>
<p><i>Slide template taken from Sylvain Wallez' <a href="https://github.com/swallez/introduction-to-rust?tab=readme-ov-file">Rust intro</a>. This is rendered through <a href="https://rust-lang.github.io/mdBook/">Mdbook</a> (which is how the Rust book is created)</i>.</p>
<p><img src="media/rust-logo-blk.svg" alt="" /></p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="this-weeks-content"><a class="header" href="#this-weeks-content">This Weeks Content</a></h1>
<ul>
<li><strong>Chapter 5 - Using Structs to Structure Related Data</strong>
<ul>
<li>Defining and Instantiating Structs</li>
<li>Example Program Using Structs</li>
<li>Method Syntax</li>
</ul>
</li>
<li><strong>Chapter 6 - Enums and Pattern Matching</strong>
<ul>
<li>Defining an Enum</li>
<li>Match program Control Flow Construct</li>
<li>Conscise Control Flow with if let and let else</li>
</ul>
</li>
<li>General thoughts</li>
<li>Coding example</li>
</ul>
<center>
<p><img src="media/ferris.gif" alt="" /></p>
</center>
<div style="break-before: page; page-break-before: always;"></div><h2 id="motivation"><a class="header" href="#motivation">Motivation</a></h2>
<p>We are all pretty busy and its been hard to find time for Rust recently. I felt some motivation may be needed.</p>
<p>By the end of our Rust journey we can confuse everyone with our Strings knowledge!
<img src="media/image-2.png" alt="alt text" /></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="structs-structures"><a class="header" href="#structs-structures">Structs (structures)!</a></h2>
<p>Grouping of related values (kind of like an object).
Some comparisons I made initally...</p>
<div class="table-wrapper"><table><thead><tr><th>Language</th><th>Equivalent to Rust Structs</th></tr></thead><tbody>
<tr><td><strong>C++</strong></td><td><code>struct</code>, <code>class</code> (without methods or with public fields)</td></tr>
<tr><td><strong>Java</strong></td><td><code>record</code></td></tr>
<tr><td><strong>Python</strong></td><td><code>dataclass</code> (Python 3.7+)?</td></tr>
<tr><td><strong>JavaScript/TypeScript</strong></td><td>Interfaces or object literals (<code>{}</code>)</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h3 id="defining"><a class="header" href="#defining">Defining</a></h3>
<p>State like tuple but we add name : type pairs (hence can be different types).
For example</p>
<pre><pre class="playground"><code class="language-rust editable">// Should this be camel case?
struct CSstudent {
    name: String, // attributes (in OOP)
    email: String,
    coffee_addict: bool,
    total_commits: u64,
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="using-structs"><a class="header" href="#using-structs">Using structs</a></h3>
<p>We create a variable and call the struct but adding concrete values after each name and can call by using attribute notation in other languages like java.</p>
<pre><pre class="playground"><code class="language-rust editable">let student1 = CS_Student {
    // Doesnt need to be in order stated
    name: String::from("Jake"),
    email: String::from("ja250@st-andrews.ac.uk"),
    coffee_addict: true,
    total_commits: 400,
}
// grab attributes like so
let jakes_email = student1.email;

// Test - why would this NOT work?
student1.email = String::from("other0@st-andrews.ac.uk");</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="other-neat-features-when-declaring"><a class="header" href="#other-neat-features-when-declaring">Other neat features when declaring</a></h3>
<ul>
<li>Can add pre known attributes (i.e dont need to init them).
<ul>
<li>If param has the same name as attribute dont can use <code>attribute</code> over <code>attribute : attribute</code> notation.</li>
</ul>
</li>
<li>Can reference other structures attributes using the <code>..structure_name</code> syntax.
<ul>
<li>Is this sort of like inheritance / overriding?</li>
<li>If we have types like u64 or bool that have copy trait would just copy over!</li>
</ul>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust editable">let student2 = CS_Student {
    name: String::from("julia"),
    email: String::from("julia@st-andrews.ac.uk"),
    ..student1  // take definitions for other attributes from student1
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="variations"><a class="header" href="#variations">Variations</a></h3>
<p><b>Tuple structs</b> - values with unnamed attributes (eg we would probally use when value meaning is implied through index). <code>struct Color(i32, i32, i32);</code> (RGB). Accessed through <code>.index</code> notation
<i>Any thoughts on other examples where we may use?</i></p>
<p><b>Unit-like structs</b> - A struct without attributes (unit). We will learn more on why we may want this when discussing traits ! This will be equal to every other type ðŸ¤¯</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="ownership-"><a class="header" href="#ownership-">OWNERSHIP .......</a></h3>
<p>When defining a struct we use <code>String</code> over <code>&amp;str</code> because we want the instances to <i>own</i> all of its data.
Can have cases where struct references data owned by someone else but we need to know about <i>lifetimes</i> :/</p>
<p>We will find out more about this in section 10 (which feels like a <i>lifetime</i> away sadly...)</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="example"><a class="header" href="#example">Example</a></h3>
<p>The docs had an example. There is no point me re stating their example but would be nice to hear peoples peoples thoughts?</p>
<p>An example I thought of was in our Knight-Tour we could potentially have a Position (position on board) struct.</p>
<pre><pre class="playground"><code class="language-rust editable">#[derive(Debug)]
// This by itself is slightly pointless (compared to tuple) 
// ... but will make more sence when we add methods
struct Position {
    x: u8,
    y: u8,
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="methods"><a class="header" href="#methods">Methods</a></h3>
<p>Intuitively Methods are basically the same as class methods in most OO languages.
We create them by using <code>impl</code> (can have multiple per struct).
No such thing as getters and setters in Rust.
We use <code>object.method()</code> notation (dont need -&gt; as rust automatically matches signature of method!).
<i>Associated functions</i> = methods that dont reference struct (i.e dont have self in params). Often use when we want to create new instance of struct.</p>
<pre><pre class="playground"><code class="language-rust editable">impl Position {
    // Check if the position is within the board boundaries
    fn valid(&amp;self) -&gt; bool {   // Using &amp;self as we just want copy of attributes (not ownership)
        (0..WIDTH).contains(&amp;self.x) &amp;&amp; (0..WIDTH).contains(&amp;self.y)
    }</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="enums"><a class="header" href="#enums">Enums</a></h2>
<p>These are used when defining types to <i>enumerate</i> through its different variants.</p>
<p>These are in other prog languages right? (python / java ect...)</p>
<p>We call then through <code>::</code> i.e we namespace it up its id.
<i>example</i></p>
<pre><pre class="playground"><code class="language-rust editable">// From book
enum IpAddrKind {
    V4,
    V6,
}

let four = IpAddrKind::V4;      // double colon for specific kind or single colon for any of that type</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="when-we-use-enums-over-structs"><a class="header" href="#when-we-use-enums-over-structs">When we use enums over structs?</a></h3>
<ul>
<li>
Say we dont know all attributes in advance only know type.
</li>
<li>
Are able to have different types for variants (cant do this with a struct).
</li>
</ul>
<pre><pre class="playground"><code class="language-rust editable">// their example
enum IpAddr {
        V4(u8, u8, u8, u8),
        V6(String),
    }</code></pre></pre>
<p>But from my understanding anything that can be done with an enum can be replicated with multiple structs (obviously a bit longer to express).
We can also use methods with enums (with <code>imp</code>)???</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="option-enum"><a class="header" href="#option-enum"><code>Option</code> Enum</a></h3>
<p>Note - I have seen this in quite a lot of rust code so I think this is quite important</p>
<p>Its basically a type where it could be something (i.e not <code>null</code>) or <code>null</code>.</p>
<p>I suppose an example of this would be popping from a stack (to be honest this would probally throw an error before I imagine)?</p>
<p>Why do we need this ? -&gt;
<b> RUST DOESNT HAVE A NULL TYPE ...</b> - What are peoples thoughts on this?</p>
<p>Option is defined as -</p>
<pre><pre class="playground"><code class="language-rust editable">enum Option&lt;T&gt; {   // we dont need to bring into scope explicitly
    None,       // We can call these directly if we want - if so can we not just think of None as null?
    Some(T), // T is a generic type parameter (we find out about this later) - T can hold any type
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="option-examples"><a class="header" href="#option-examples">Option examples</a></h3>
<p>Rust will infer the type T.</p>
<pre><pre class="playground"><code class="language-rust editable">    let some_number = Some(5);      // infers i32
    let some_char = Some('e');      // infers char

    let absent_number: Option&lt;i32&gt; = None;  // of type Option&lt;i32&gt; as we dont know what type some would be</code></pre></pre>
<p>But we need to note <code>Option&lt;T&gt; != T</code>! meaning we cant do normal type operations with Option if we have defined T with Some(value) (eg cannot add <code>Option&lt;i8&gt;</code> to <code>i8</code>). To fix this we must covert <code>Option&lt;T&gt;</code> to <code>T</code> by ensuring its not null. This means if we see a type that isnt <code>Option&lt;T&gt;</code> we know it cant be null!</p>
<img alt="" class="bh gt pa c" width="498" height="301" loading="eager" role="presentation" src="https://miro.medium.com/v2/resize:fit:996/1*EyBu3xyslFozyfa_UUlK0w.gif">
<div style="break-before: page; page-break-before: always;"></div><h3 id="match-control-flow-construct"><a class="header" href="#match-control-flow-construct"><code>Match</code> Control flow construct</a></h3>
<p>A bit like a more powerful version of Switch in Python / Java.</p>
<pre><pre class="playground"><code class="language-rust editable">
// Example they gave - helps us tell what variant of the type it is
enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter,
}

fn value_in_cents(coin: Coin) -&gt; u8 {
    match coin {
        Coin::Penny =&gt; 1,       // These are the arms (have talked about this already)
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,       // for multiline return statements on an arm use =&gt; {... u8} notation
        Coin::Quarter =&gt; 25,
    }
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="matching-with-optiont"><a class="header" href="#matching-with-optiont">Matching with <code>Option&lt;T&gt;</code></a></h3>
<p>The same idea as before but now the arms are <code>None</code> and <code>Some(T)</code> as these are the variants of Option.</p>
<p>This is useful for handling when we have the something there and when there isnt, for example we couldnt add <code>Option&lt;i8&gt;</code> to <code>i8</code> directly because of the <code>null</code> case so we handle it like so.</p>
<pre><pre class="playground"><code class="language-rust editable">    fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
        match x {
            None =&gt; None,
            Some(i) =&gt; Some(i + 1),
        }
    }

    let five = Some(5);
    let six = plus_one(five);
    let none = plus_one(None);</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="match-everything"><a class="header" href="#match-everything">Match everything</a></h3>
<p>We must remember if we use <code>match</code> to handle all variants! eg if we didnt handle the None arm then we would get an error as match is exhaustive!
Can use <code>other</code> or <code>_</code> to catch all other cases (like <code>default</code> in cases)</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="if-let-and-let-else"><a class="header" href="#if-let-and-let-else"><code>if let</code> and <code>let else</code></a></h3>
<p>Essentially for when we want to do matches on an <code>Option&lt;T&gt;</code> for example but only care about a certain arm (i.e dont do anything if it doesnt match on said arm).</p>
<p>However - this is means less exhaustive checking but shorter code.</p>
<p>We can replicate the behaviour of <code>_</code> / <code>other</code> with <code>else</code> -&gt;</p>
<pre><code class="language-let mut count = 0;">    if let Coin::Quarter(state) = coin {
        println!("State quarter from {state:?}!");
    } else {
        count += 1;
    }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="let-else-happy-path"><a class="header" href="#let-else-happy-path"><code>let else</code> (happy path)</a></h3>
<p>If the pattern matches go the outer loop but if it doesnt execute whats inside the let else. This is known as the <i>"happy path"</i> as we dont need to change scope to deal with the case of no pattern match.</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="example-1"><a class="header" href="#example-1">Example</a></h3>
<p>In our knights tour we had -</p>
<pre><pre class="playground"><code class="language-rust editable">match visited.iter().position(|a| a == &amp;(x, y)) {
    Some(i) =&gt; print!("{:&gt;3}", i),
    None =&gt; print!("  .")
};</code></pre></pre>
<p>Given what we have learnt we could use if let instead!</p>
<pre><pre class="playground"><code class="language-rust editable">
if let Some(i) = visited.iter().position(|a| a == &amp;(x, y)) {
    print!("{:&gt;3}", i);
} else {
    print!("  .");
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="thanks-for-listening"><a class="header" href="#thanks-for-listening">Thanks for listening</a></h3>
<p>Time for any questions / other thoughts ...</p>
<p><img src="media/image-3.png" alt="alt text" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="slide-23"><a class="header" href="#slide-23">Slide 23</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>

        <script src="ace.js"></script>
        <script src="editor.js"></script>
        <script src="mode-rust.js"></script>
        <script src="theme-dawn.js"></script>
        <script src="theme-tomorrow_night.js"></script>


        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
